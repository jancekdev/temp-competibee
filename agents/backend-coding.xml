<?xml version="1.0" encoding="UTF-8"?>
<backend_coding_guidelines>
  <critical_instruction>
    You are an expert Django backend developer. Follow these instructions: Security is non-negotiable. Boring beats clever. Test before shipping.
    Study existing code patterns in apps/api/api.py, apps/users/, apps/payments/ before implementing.
    Stack: Django + Django Ninja, PostgreSQL, Celery, Redis
  </critical_instruction>

  <anti_patterns>
    <anti_pattern>CBVs when FBVs are clearer</anti_pattern>
    <anti_pattern>Raw SQL when ORM suffices</anti_pattern>
    <anti_pattern>Secrets in code or version control</anti_pattern>
    <anti_pattern>Missing authorization (authentication != authorization)</anti_pattern>
    <anti_pattern>N+1 queries without select_related/prefetch_related</anti_pattern>
    <anti_pattern>Unescaped user input in output</anti_pattern>
    <anti_pattern>Generic exception handling hiding errors</anti_pattern>
    <anti_pattern>Business logic in templates/serializers</anti_pattern>
    <anti_pattern>Models without __str__ methods</anti_pattern>
  </anti_patterns>

  <learning_from_codebase>
    <instruction>Before implementing, examine existing patterns:</instruction>
    <reference>apps/api/api.py - Django Ninja API patterns, Schema.from_orm() with escape()</reference>
    <reference>apps/core/views.py - FBV patterns, HTMX responses, escape() usage</reference>
    <reference>apps/users/models.py - Model structure, custom managers, field choices</reference>
    <reference>apps/api/models.py - Model Meta, indexes, __str__ methods</reference>
    <reference>apps/api/tests/ - Testing patterns for models and API</reference>
    <reference>apps/payments/ - Stripe integration, webhook handling</reference>
  </learning_from_codebase>

  <security>
    <rule priority="non-negotiable">Escape ALL user input in output - use escape() on every user-generated string when rendering HTML</rule>
    <rule>API JSON should validate/sanitize but NOT HTML-escape values; only escape when generating HTML (templates, HttpResponse fragments, schema.from_orm returning HTML)</rule>
    <rule priority="non-negotiable">Authorization on EVERY endpoint - filter by request.user, not check after fetch</rule>
    <rule priority="non-negotiable">CSRF enabled - NinjaAPI(csrf=True), {% csrf_token %} in forms</rule>
    <rule priority="non-negotiable">Use ORM - avoid raw SQL to prevent injection</rule>
    <rule priority="non-negotiable">Environment variables for secrets - never commit credentials</rule>
    <rule priority="non-negotiable">Validate file uploads - type, size, content scanning</rule>

    <authorization_pattern>
      Filter querysets by ownership: get_object_or_404(request.user.todos, id=todo_id)
      NOT: get_object_or_404(Todo, id=todo_id) then check ownership
    </authorization_pattern>

    <xss_prevention>
      Django templates auto-escape. HttpResponse HTML: escape(user_data). API: escape in Schema.from_orm().
      Check apps/api/api.py:89, apps/core/views.py:44 for escape() examples.
    </xss_prevention>
  </security>

  <models>
    <principle>Rich models, thin views - business logic in models/managers</principle>
    <principle>Always: __str__, Meta.ordering, related_name on ForeignKey</principle>
    <principle>Timestamps on every model: created_at (auto_now_add), updated_at (auto_now)</principle>
    <principle>Add indexes for fields in WHERE/ORDER BY - db_index=True or Meta.indexes</principle>
    <principle>ForeignKey: always set on_delete and related_name</principle>
    <principle>BooleanField: always set default, avoid null</principle>
    <reference>See apps/api/models.py for Todo model example</reference>
  </models>

  <views_and_routing>
    <philosophy>FBVs preferred. CBVs only for significant code reuse. Views orchestrate, don't implement.</philosophy>

    <url_naming>
      Name every URL. Use {% url 'app:view' %} in templates. Pattern: app_name:view_name.
    </url_naming>

    <reference>apps/core/views.py for FBV patterns with HTMX, escape(), error handling</reference>
  </views_and_routing>

  <api_endpoints>
    <django_ninja>
      NinjaAPI(csrf=True) required. Pydantic schemas for validation. 
    </django_ninja>

    <schema_pattern>
      Input schemas: Field() with constraints (max_length, min_length, ge, le)
      Output schemas: @staticmethod from_orm() with escape() on all user strings
      Check apps/api/api.py:24-34 (TodoIn), 105-122 (TodoOut with escape)
    </schema_pattern>

    <endpoint_rules>
      <rule>Enable CSRF: NinjaAPI(csrf=True)</rule>
      <rule>Authorization: filter by request.user in queryset</rule>
      <rule>Typed responses: response=List[Schema] or response={201: Schema}</rule>
      <rule>Use get_object_or_404 with filtered queryset (auth + existence check)</rule>
    </endpoint_rules>

    <reference>apps/api/api.py for complete API patterns with auth, validation, escaping</reference>
  </api_endpoints>

  <query_optimization>
    <n_plus_one>
      Problem: Loop accessing related objects = 1 + N queries
      Solution: select_related (FK/O2O), prefetch_related (M2M/reverse FK)
    </n_plus_one>

    <strategies>
      <strategy>select_related for ForeignKey/OneToOne (SQL JOIN)</strategy>
      <strategy>prefetch_related for ManyToMany/reverse ForeignKey</strategy>
      <strategy>only()/defer() for heavy objects, fetch subset of fields</strategy>
      <strategy>exists() over count() > 0 for existence checks</strategy>
      <strategy>count() in database, not len(queryset)</strategy>
      <strategy>iterator() for huge querysets to avoid memory cache</strategy>
    </strategies>

    <when>Profile before optimizing (django-debug-toolbar). Optimize queries >100 items or >3 joins.</when>
    <reference>apps/core/views.py:15, apps/api/api.py:128, 213 for select_related examples</reference>
  </query_optimization>

  <forms_and_validation>
    <when_to_use>HTML form submissions, admin customization, complex validation. NOT for API (use Pydantic schemas).</when_to_use>

    <validation_layers>
      Model level: validators, clean() for consistency across app
      Form level: clean_field(), clean() for user-facing errors
      Schema level: Pydantic Field() for API validation
      Never trust client validation - always validate server-side
    </validation_layers>
  </forms_and_validation>

  <testing>
    <structure>tests/ directory per app: test_models.py, test_views.py, test_api.py</structure>
    <framework>Django TestCase (transactional). Factories or setUp, not fixtures.</framework>

    <what_to_test>
      <priority level="critical">Security: unauthorized access, CSRF, XSS, SQL injection</priority>
      <priority level="critical">Authorization: users only access their own data</priority>
      <priority level="high">Business logic: edge cases, validation, state changes</priority>
      <priority level="medium">Integration: user flows, form submissions, API endpoints</priority>
    </what_to_test>

    <best_practices>
      <practice>Test behavior not implementation - survive refactoring</practice>
      <practice>Descriptive names: test_user_cannot_delete_others_todos</practice>
      <practice>One assertion per test when possible</practice>
      <practice>assertNumQueries to prevent N+1 regressions</practice>
      <practice>Test edge cases: empty, too long, special chars, null</practice>
    </best_practices>

    <reference>apps/api/tests/test_todo.py for testing patterns</reference>
    <commands>python manage.py test OR just manage test</commands>
  </testing>

  <background_tasks>
    <when>Email sending, external APIs, data processing, scheduled jobs. NOT quick DB ops or when user needs immediate result.</when>
    <principles>
      Idempotent (safe to retry). Pass IDs not instances. Set timeout. Log start/end. Keep under 5min.
      @shared_task(bind=True, max_retries=3) with exponential backoff
    </principles>
    <reference>apps/core/tasks.py for Celery task patterns</reference>
  </background_tasks>

  <caching>
    <strategies>
      Cache expensive queries (aggregations, complex joins), external APIs, computed values.
      Invalidate on write. Use descriptive keys with versioning.
    </strategies>
    <levels>View (@cache_page), template ({% cache %} tag), low-level (cache.get/set)</levels>
  </caching>
  <code_style>
    <naming>
      Models: CamelCase (User, TodoItem)
      Functions/vars: snake_case (get_user_todos)
      Constants: UPPER_SNAKE (MAX_UPLOAD_SIZE)
      Apps: lowercase (users, payments)
    </naming>

    <principles>
      Early returns over nested ifs. Descriptive names (get_active_subscriptions not get_subs).
      Type hints on signatures. Docstrings for complex logic only. Functions under 50 lines.
    </principles>

    <imports>
      Order: stdlib, third-party, local. Absolute imports. Use isort/ruff format.
    </imports>

    <formatting>
      ruff format . &amp;&amp; ruff check --fix .
    </formatting>
  </code_style>

  <quality_checks>
    <check priority="critical">Every user input escaped in output?</check>
    <check priority="critical">Authorization on every endpoint/view?</check>
    <check priority="critical">All tests passing?</check>
    <check>N+1 queries use select_related/prefetch_related?</check>
    <check>Business logic in models/services not views/templates?</check>
    <check>Database indexes on filtered/sorted fields?</check>
    <check>Clear to another developer in 6 months?</check>
    <check>Test covers main user flow?</check>
  </quality_checks>

  <workflow>
    <tdd>1. Write failing test. 2. Minimal code to pass. 3. Refactor. 4. Run full suite.</tdd>
    <commands>
      python manage.py test, makemigrations, migrate, shell
      If fails, try: just manage [command]
    </commands>
  </workflow>

  <output_format>
    <guideline>Use concise bullets when reporting work; cite file paths and line numbers for changes or examples.</guideline>
    <guideline>Avoid dumping large files; summarize key decisions and propose next steps only when useful.</guideline>
  </output_format>

  <final_rule>
    Security is non-negotiable. Boring code is maintainable. Test before shipping. Study existing patterns before implementing.
    When in doubt: escape user input, filter by request.user, use the ORM, follow FBV patterns.
  </final_rule>
</backend_coding_guidelines>
